[
["data-structures.html", "Chapter 3 Data structures 3.1 Basic concepts 3.2 Data structures 3.3 For more in-depth exercises", " Chapter 3 Data structures R data types and basic expressions1 : Common data structures in R include scalars, vectors, matrices, factors, data frames, and lists. These data structures can contain one or more individual data elements of several types, namely numeric (2.5), character (“Go Jacks”), or logical (TRUE or FALSE). 3.1 Basic concepts 3.1.1 Expressions Type anything at the prompt, and R will evaluate it and print the answer. 1 + 1 ## [1] 2 There’s your result, 2. It’s printed on the console right after your entry. Type the string “Go Jacks”. (Don’t forget the quotes!) &quot;Go Jacks&quot; ## [1] &quot;Go Jacks&quot; Exercise 3.1 Now try multiplying 45.6 by 78.9. 3.1.2 Logical Values Some expressions return a “logical value”: TRUE or FALSE. (Many programming languages refer to these as “boolean” values.) Let’s try typing an expression that gives us a logical value: 3 &lt; 4 ## [1] TRUE And another logical value (note that you need a double-equals sign to check whether two values are equal - a single-equals sign won’t work): 2 + 2 == 5 ## [1] FALSE T and F are shorthand for TRUE and FALSE. Try this: T == TRUE ## [1] TRUE 3.1.3 Variables As in other programming languages, you can store a value into a variable to access it later. Type x = 42 to store a value in x. x is a scalar, with only one data element. x = 42 You can also use the following. This is a conventional, safer way to assign values. x &lt;- 42 x can now be used in expressions in place of the original result. Try dividing x by 2 (/ is the division operator), and other calculations. x / 2 ## [1] 21 log(x) ## [1] 3.73767 x^2 ## [1] 1764 sqrt(x) ## [1] 6.480741 x &gt; 1 ## [1] TRUE You can re-assign any value to a variable at any time. Try assigning “Go Jacks!” to x. x &lt;- &quot;Go Jacks!&quot; You can print the value of a variable at any time just by typing its name in the console. Try printing the current value of x. x ## [1] &quot;Go Jacks!&quot; Now try assigning the TRUE logical value to x. x &lt;- TRUE You can store multiple values in a variable or object. That is called a vector, which is explained below. An object can also contain a table with rows and columns, like an Excel spreadsheet, as a matrix, or data frame. 3.1.4 Functions You call a function by typing its name, followed by one or more arguments to that function in parenthesis. Most of your R commands are functional calls. Let’s try using the sum function, to add up a few numbers. Enter: sum(1, 3, 5) ## [1] 9 Some arguments have names. For example, to repeat a value 3 times, you would call the rep function and provide its times argument: rep(&quot;Yo ho!&quot;, times = 3) ## [1] &quot;Yo ho!&quot; &quot;Yo ho!&quot; &quot;Yo ho!&quot; Exercise 3.2 Suppose a vector is definded as x &lt;- c(12, 56, 31, -5, 7). Calculate the mean of all elements in x, assign the mean to y. Squared each element in x and assign the result in a new vector z. Exercise 3.3 Try to find and run the two functions that sets and returns the current working directory. Exercise 3.4 Try to find and run the function that lists all the files in the current working folder. Many times, we want to re-use a chunk of code. The most efficient way is to wrap these code as a function, clearly define what the input and the output. Functions are fundamental building blocks of R. Most of the times when we run R commands, we are calling and executing functions. We can easily define our very own functions. For example, we have the following arithmetic function: \\[f(x)=1.5 x^3+ x^2-2x+1\\] Obviously, we can use the following code to do the computing: x &lt;- 5 1.57345 * x ^ 3 + x ^ 2 - 2 * x + 1 ## [1] 212.6813 This will work, but every time we have to re-write this code. So let’s try to define our own function: myf &lt;- function(x) { y = 1.57345 * x ^ 3 + x ^ 2 - 2 * x + 1 return(y) } Note that “{” and “}” signify the beginning and end of a block of code. “function” tells R that a function is going to be defined. At the end, the “return” statement returns the desired value. You can copy and paste the 4 lines of code to R and it defines a function called myf, which you can call by: myf(5) # or myf(x = 5) ## [1] 212.6813 As you can see you get the same results when x=5. But now you can use this in many ways. x &lt;- - 10 : 10 # x now is a vector with 21 numbers -10, -9, … 10 myf(x) ## [1] -1452.45000 -1047.04505 -724.60640 -475.69335 -290.86520 ## [6] -160.68125 -75.70080 -26.48315 -3.58760 2.42655 ## [11] 1.00000 1.57345 13.58760 46.48315 109.70080 ## [16] 212.68125 364.86520 575.69335 854.60640 1211.04505 ## [21] 1654.45000 plot(x, myf(x)) # see plot on the right. Obviously functions can handle many different calculations beyond arithmetic functions. It can take in one or more inputs and return a list of complex data objects too. Exercise 3.5 Write an R function to implement this arithmetic function: f(x)= |x|+5x-6. Note |x| means the absolute value of x. Use this function to find f(4.534), and also produce a plot like the example. Let’s define a function to count even numbers in a vector. #counts the number of even intergers in vec evencount &lt;- function(vec) { k &lt;- 0 # assign o to i #assign 0 to a count varialbe k for (i in vec) { #set i to vec[1],vec[2],... if (i %% 2 == 0) k &lt;- k + 1 # test if i is an even or odd number. %% is the modulo operator } return(k) #print the computed value of k } x=c(2, 5, 7, 8, 14, 12, 8, 3) #a vector evencount(x) #Call the function evencount(). ## [1] 5 A vaiable is called local variable if it is only visible within a function. Such as k and vec are local variables to the function evencount(). They disappear after the function returns. k Error: object ‘vec’ not found vec Error: object ‘vec’ not found A variable is called global variable if it is defined outside of functions.A global variable is also available within functions. Here is an example: myfun.globle &lt;- function (x){ y &lt;- 1 return(x - 2 * y) } myfun.globle(8) # set x=8, and do the calculation: 8-2*y = 8-2*(1)=6 ## [1] 6 Here y is a global variable. The function myfun.globle2() defined below returns the same values as above. But both x and y within the the paratheses (x, y=1) following function are local variables. myfun.globle2 &lt;- function (x, y = 1){ #y is set as 1 within the function by default. return(x - 2 * y) } myfun.globle2(8) #8-2*y = 8-2*(1)=6 ## [1] 6 Exercise 3.6 Define a function counting the values that are less than 0 for two vectors x=rnorm(50) and y=rnorm(5000) respectively. Define another function to calcute the proportion that values are less than 0 for x and y respectively. Compare calculated proportions with theoretical proportion 0.5, what conclusions can you make? 3.1.5 Looking for Help and Example Code ? sum A web page will pope up. This is the official help information for this function. At the bottom of the page is some example code. The quickest way to learn an R function is to run the example codes and see the input and output. You can easily copy, paste, and twist the example code to do your analysis. example() brings up examples of usage for the given function. Try displaying examples for the min function: example(min) ## ## min&gt; require(stats); require(graphics) ## ## min&gt; min(5:1, pi) #-&gt; one number ## [1] 1 ## ## min&gt; pmin(5:1, pi) #-&gt; 5 numbers ## [1] 3.141593 3.141593 3.000000 2.000000 1.000000 ## ## min&gt; x &lt;- sort(rnorm(100)); cH &lt;- 1.35 ## ## min&gt; pmin(cH, quantile(x)) # no names ## [1] -2.18609476 -0.66578026 0.01205089 0.70654858 1.35000000 ## ## min&gt; pmin(quantile(x), cH) # has names ## 0% 25% 50% 75% 100% ## -2.18609476 -0.66578026 0.01205089 0.70654858 1.35000000 ## ## min&gt; plot(x, pmin(cH, pmax(-cH, x)), type = &quot;b&quot;, main = &quot;Huber&#39;s function&quot;) ## ## min&gt; cut01 &lt;- function(x) pmax(pmin(x, 1), 0) ## ## min&gt; curve( x^2 - 1/4, -1.4, 1.5, col = 2) ## ## min&gt; curve(cut01(x^2 - 1/4), col = &quot;blue&quot;, add = TRUE, n = 500) ## ## min&gt; ## pmax(), pmin() preserve attributes of *first* argument ## min&gt; D &lt;- diag(x = (3:1)/4) ; n0 &lt;- numeric() ## ## min&gt; stopifnot(identical(D, cut01(D) ), ## min+ identical(n0, cut01(n0)), ## min+ identical(n0, cut01(NULL)), ## min+ identical(n0, pmax(3:1, n0, 2)), ## min+ identical(n0, pmax(n0, 4))) min(5:1, pi) # -&gt; one number ## [1] 1 Example commands and plots will show up automatically by typing Return in RStudio. In R, you need to click on the plots. example(boxplot) # bring example of boxplot I found a lot of help information about R through Google. Google tolerate typos, grammar errors, and different notations. Also, most (99 %) of your questions have been asked and answered on various forums. Many R gurus answered a ton of questions on web sites like** stackoverflow.com**, with example codes! I also use Google as a reference. It is important to add comments to your code. Everything after the “#” will be ignored by R when running. We often recycle and repurpose our codes. max(1, 3, 5) # return the maximum value of a vector ## [1] 5 3.2 Data structures 3.2.1 Vectors A vector is an object that holds a sequence of values of the same type. A vector’s values can be numbers, strings, logical values, or any other type, as long as they’re all the same type. They can come from a column of a data frame. if we have a vector x: x &lt;- c(5, 2, 22, 11, 5) x ## [1] 5 2 22 11 5 Here c stands for concatenate, do not use it as variable name. It is as special as you! Vectors can not hold values with different modes (types). Try mixing modes and see what happens: c(1, TRUE, &quot;three&quot;) ## [1] &quot;1&quot; &quot;TRUE&quot; &quot;three&quot; All the values were converted to a single mode (characters) so that the vector can hold them all. To hold diverse types of values, you will need a list, which is explained later in this chapter. If you need a vector with a sequence of numbers you can create it with start:end notation. This is often used in loops and operations on the indices of vectors etc. Let’s make a vector with values from 5 through 9: 5:9 ## [1] 5 6 7 8 9 A more versatile way to make sequences is to call the seq function. Let’s do the same thing with seq: seq(from = 5, to = 9) ## [1] 5 6 7 8 9 seq also allows you to use increments other than 1. Try it with steps of 0.5: seq(from = 5, to = 9, by = .5) ## [1] 5.0 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0 Create a sequence from 5 to 9 with length 15: seq(from = 5, to = 9, length = 15) ## [1] 5.000000 5.285714 5.571429 5.857143 6.142857 6.428571 6.714286 ## [8] 7.000000 7.285714 7.571429 7.857143 8.142857 8.428571 8.714286 ## [15] 9.000000 Exercise 3.7 Compute 1+2+3… +1000 with one line of R code. Hint: examine the example code for sum( ) function in the R help document. 3.2.1.1 Commands about vector Next we will try those commands about vector. First let’s find out what is the 4th element of our vector x &lt;- c(5, 2, 22, 11, 5), or the elements from 2 to 4. x[4] ## [1] 11 x[2:4] ## [1] 2 22 11 If you define the vector as y, y &lt;- x[2:4] No result is returned but you “captured” the result in a new vector, which holds 3 numbers. You can type y and hit enter to see the results. Or do some computing with it. y &lt;- x[2:4]; y ## [1] 2 22 11 This does exactly the same in one line. Semicolon separates multiple commands. Now if we want to know the number of elements in the vector length(x) ## [1] 5 It’s also easy to know about the maximum, minimum, sum, mean and median individually or together. We can get standard deviation too. max(x) ## [1] 22 min(x) ## [1] 2 sum(x) ## [1] 45 mean(x) ## [1] 9 median(x) ## [1] 5 summary(x) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2 5 5 9 11 22 sd(x) ## [1] 7.968689 rank() function ranks the elements. Ties are shown as the average of these ranks. While sort() will sort from the smallest to the biggest, decreasing = T will make it sort form the biggest to the smallest. rank(x) ## [1] 2.5 1.0 5.0 4.0 2.5 sort(x) ## [1] 2 5 5 11 22 sort(x, decreasing = T) ## [1] 22 11 5 5 2 diff() lag and iterate the differences of vector x. diff(x) ## [1] -3 20 -11 -6 rev() will reverse the position of the elements in the vector. rev(x) ## [1] 5 11 22 2 5 Operations are performed element by element. Same for log, sqrt, x^2, etc. They return vectors too. log(x) ## [1] 1.6094379 0.6931472 3.0910425 2.3978953 1.6094379 sqrt(x) ## [1] 2.236068 1.414214 4.690416 3.316625 2.236068 x^2 ## [1] 25 4 484 121 25 2*x + 1 ## [1] 11 5 45 23 11 If we don’t want the second element and save it as y: y &lt;- x[-2] y ## [1] 5 22 11 5 Add an element 100 to the vector x between the second and the third element: x &lt;- c(5, 2, 22, 11, 5) x &lt;- c(x[1:2], 100, x[3:5] ) #add an element 100 to x between elements 8 and 9 x #The value 100 is added to the previous vector x ## [1] 5 2 100 22 11 5 Length of the new created x is: length(x) ## [1] 6 To add a new element to the end, we can use the two commands below, they generate same result. x &lt;- c(5, 2, 22, 11, 5) c(x, 7) ## [1] 5 2 22 11 5 7 append(x, 7) ## [1] 5 2 22 11 5 7 Creat an empty vector y: y &lt;- c() y ## NULL length(y) ## [1] 0 Sometimes we are interested in unique elements: x &lt;- c(5, 2, 22, 11, 5) unique(x) ## [1] 5 2 22 11 And the frequencies of the unique elements: x &lt;- c(5, 2, 22, 11, 5) table(x) ## x ## 2 5 11 22 ## 1 2 1 1 If we are interested in the index of the maximum or minimum: x &lt;- c(5, 2, 22, 11, 5) which.max(x) ## [1] 3 which.min(x) ## [1] 2 Or we need to look for the location of a special value: x &lt;- c(5, 2, 22, 11, 5) which(x == 11) ## [1] 4 Or more complicated, we want to find the locations where \\(x^2&gt;100\\): x &lt;- c(5, 2, 22, 11, 5) x^2 ## [1] 25 4 484 121 25 which (x^2 &gt; 100) ## [1] 3 4 We can randomly select some elements from the vector. Run the following code more than once, do you always get the same results? The answer is “No”. Because the 3 elements are randomly selected. x &lt;- c(5, 2, 22, 11, 5) sample(x, 3) ## [1] 5 11 2 Elements in the vector can have names. Type “x” in the command window to see the difference. x &lt;- c(5, 2, 22, 11, 5) names(x) &lt;- c(&quot;David&quot;, &quot;Breck&quot;, &quot;Zach&quot;, &quot;Amy&quot;, &quot;John&quot;) x ## David Breck Zach Amy John ## 5 2 22 11 5 Now we can refer to the elements by their names. x[&quot;Amy&quot;] ## Amy ## 11 The any() and all() functions produce logical values. They return if any of all of their arguments are TRUE. x &lt;- c(5, 2, 22, 11, 5) any(x &lt; 10) ## [1] TRUE x &lt;- c(5, 2, 22, 11, 5) any(x &lt; 0) ## [1] FALSE x &lt;- c(5, 2, 22, 11, 5) all(x &lt; 10) ## [1] FALSE x &lt;- c(5, 2, 22, 11, 5) any(x &gt; 0) ## [1] TRUE x&gt;10 ## [1] FALSE FALSE TRUE TRUE FALSE If we want to get a subset from a vector, there are multiple methods can be used.Here are some examples: x &lt;- c(NA, 2, -4, NA, 9, -1, 5) x ## [1] NA 2 -4 NA 9 -1 5 y &lt;- x[x &lt; 0] y ## [1] NA -4 NA -1 There are annoying NAs in the subset y. We can remove the NAs by applying na.rm() function to y. Or we can use the subset() function to get a “clean” data without NAs. subset(x, x &lt; 0) ## [1] -4 -1 The ifelse() function allows us do conditional element selection. The usage is ifelse(test, yes, no). The yes and no depends on the test is true of false. Here are two examples. x &lt;- c(2, -3, 4, -1, -5, 6) y &lt;- ifelse(x &gt; 0, &#39;Positive&#39;, &#39;Negative&#39;) y ## [1] &quot;Positive&quot; &quot;Negative&quot; &quot;Positive&quot; &quot;Negative&quot; &quot;Negative&quot; &quot;Positive&quot; In this example, the element in y is either ‘positive’ or ‘negative’. It depends on x greater than 0 or less than 0. x &lt;- c(3, 4, -6, 1, -2) y &lt;- ifelse (x &lt; 0, abs(x), 2 * x + 1) y ## [1] 7 9 6 3 2 In this example, if an element in x is less than 0, then take the absolute value of the element. Otherwise multiply the element by 2 then add 1. Exercise 3.8 Using sample selction function randomly select 10 integers from 1 to 100. Create a vector y which satisfies the following conditions: if an selcted integer is an even number, then y returns ‘even’, otherwise y returns ‘odd’. If we have two vectors and try to compare them with each other: x &lt;- c(5, 2, 22, 11, 5) y &lt;- c(5, 11, 8) z &lt;- match(y, x) z ## [1] 1 4 NA match() returns the locations in 2nd vector. NA means missing, not found. To check if NA is in a vector, we use the function is.na( ). Note that the result is a vector holding logical values. Do we have missing value in our vector? is.na(x) ## [1] FALSE FALSE FALSE FALSE FALSE is.na(z) ## [1] FALSE FALSE TRUE Sometimes, when working with sample data, a given value isn’t available. But it’s not a good idea to just throw those values out. R has a value that explicitly indicates a sample was not available: NA. Many functions that work with vectors treat this value specially. For our z vector, try to get the sum of its values, and see what the result is: sum(z) ## [1] NA The sum is considered “not available” by default because one of the vector’s values was NA. This is the responsible thing to do; R won’t just blithely add up the numbers without warning you about the incomplete data. We can explicitly tell sum (and many other functions) to remove NA values before they do their calculations, however. Bring up documentation for the sum function: ? sum sum package:base R Documentation … As you see in the documentation, sum can take an optional named argument, na.rm. It’s set to FALSE by default, but if you set it to TRUE, all NA arguments will be removed from the vector before the calculation is performed. Try calling sum again, with na.rm parameter set to TRUE: sum(z, na.rm = TRUE) ## [1] 5 Exercise 3.9 Now compute the average of values in z. Ignore the missing values. Let’s using examples to show the differences between NULL and NA. # build up a vector of numbers greater than 10 in vector vec.x vec.x &lt;- c(40, 3, 11, 0, 9) z1 &lt;- NULL for (i in vec.x) { if (i &gt; 10) z1 &lt;- c(z1, i) } z1 ## [1] 40 11 length(z1) ## [1] 2 # build up a vector of numbers greater than 10 in vector vec.x vec.x &lt;- c(40, 3, 11, 0, 9) z2 &lt;- NA for (i in vec.x) { if (i &gt; 10) z2 &lt;- c(z2, i) } z2 ## [1] NA 40 11 length(z2) ## [1] 3 Comparing the length of z1 and z2, we know the NULL is counted as nonexistent, but the NA is counted as a missing value. Let’s do some opertations related to vectors. Firsly, we start from the operation between a vector and a scalar. # Operation between x and a scalar x &lt;- c(1, 4, 8, 9, 10) y &lt;- 1 x+y ## [1] 2 5 9 10 11 As you can see, 1 is added to each element in x. The operation is equivalent to: x &lt;- c(1, 4, 8, 9, 10) y &lt;- c(1, 1, 1, 1, 1) x+y ## [1] 2 5 9 10 11 The operation between vectors with same length is element-wise. For example: # Operation between two vectors with same length x &lt;- c(1, 4, 8, 9, 10) y &lt;- c(1, 2, 0, 3, 15) x+y ## [1] 2 6 8 12 25 x*y ## [1] 1 8 0 27 150 If vectors have different length, then R will automatically recycles the shorter one, untill it has the same length as the longer one. For example: x &lt;- c(1, 4, 8, 9, 10) y &lt;- c(1, 2) x+y ## Warning in x + y: longer object length is not a multiple of shorter object ## length ## [1] 2 6 9 11 11 The y was recyled, in fact the real operation is showed below: x &lt;- c(1, 4, 8, 9, 10) y &lt;- c(1, 2, 1, 2, 1) x+y ## [1] 2 6 9 11 11 3.2.1.2 Scatter Plots of two vectors The plot function takes two vectors, one for X values and one for Y values, and draws a graph of them. Let’s draw a graph showing the relationship of numbers and their sines. x &lt;- seq(1, 20, 0.1) y &lt;- sqrt(x) Then simply call plot with your two vectors: plot(x, y) Great job! Notice on the graph that values from the first argument (x) are used for the horizontal axis, and values from the second (y) for the vertical. Exercise 3.10 Create a vector with 21 integers from -10 to 10, and store it in the x variable. Then create a scatterplot of x^2 against x. 3.2.1.3 Fish example of vector Once upon a time, Tom, Jerry, and Mickey went fishing and they caught 7, 3, and 9 fishes, respectively. This information can be stored in a vector, like this: c(7, 3, 9) ## [1] 7 3 9 The c() function creates a new vector by combining a set of values. If we want to continue to use the vector, we hold it in an object and give it a name: fishes &lt;- c(7, 3, 9) fishes ## [1] 7 3 9 fishes is a vector with 3 data elements. There are many functions that operate on vectors. You can plot the vector: barplot(fishes) # see figure 6.1A You can compute the total: sum(fishes) ## [1] 19 We can access the individual elements by indices: fishes[3] ## [1] 9 Exercise 3.11 Does Mickey caught more fishes than Tom and Jerry combined? Write R code to verify this statement using the fishes vector and return a TRUE or FALSE value. Jerry protested that the ¼ inch long fish he caught and released per fishing rules was not counted properly. We can change the values in the 2nd element directly by: fishes[2] &lt;- fishes[2] + 1 On the left side, we take the current value of the 2nd element, which is 3, and add an 1 to it. The result (4) is assigned back to the 2nd element itself. As a result, the 2nd element is increased by 1. This is not an math equation, but a value assignment operation. More rigorously, we should write this as fishes[2] &lt;- fishes[2] + 1 We can also directly overwrite the values. fishes[2] &lt;- 4 fishes ## [1] 7 4 9 They started a camp fire, and each ate 1 fish for dinner. Now the fishes left: fishes2 &lt;- fishes - 1 fishes2 ## [1] 6 3 8 Most arithmetic operations work just as well on vectors as they do on single values. R subtracts 1 from each individual element. If you add a scalar (a single value) to a vector, the scalar will be added to each value in the vector, returning a new vector with the results. While they are sleeping in their camping site, a fox stole 3 fishes from Jerry’s bucket, and 4 fishes from Mickey’s bucket. How many left? stolen &lt;- c(0, 3, 4) # a new vector fishes2 - stolen ## [1] 6 0 4 If you add or subtract two vectors of the same length, R will take the corresponding values from each vector and add or subtract them. The 0 is necessary to keep the vector length the same. Proud of himself, Mickey wanted to make a 5ft x 5ft poster to show he is the best fisherman. Knowing that a picture worthes a thousand words, he learned R and started plotting. He absolutely needs his names on the plots. The data elements in a vector can have names or labels. names(fishes) &lt;- c(&quot;Tom&quot;, &quot;Jerry&quot;, &quot;Mickey&quot;) The right side is a vector, holding 3 character values. These values are assigned as the names of the 3 elements in the fishes vector. names is a built-in function. Our vector looks like: fishes ## Tom Jerry Mickey ## 7 4 9 barplot(fishes) # see figure 6.1B Figure 3.1: Simple Bar plot Assigning names for a vector also enables us to use labels to access each element. Try getting the value for Jerry: fishes[&quot;Jerry&quot;] ## Jerry ## 4 Exercise 3.12 Now see if you can set the value for Tom to something other than 5 using the name rather than the index. Tom proposes that their goal for next fishing trip is to double their catches. 2 * fishes ## Tom Jerry Mickey ## 14 8 18 Hopelessly optimistic, Jerry proposed that next time each should “square” their catches, so that together they may feed the entire school. sum(fishes ^ 2) ## [1] 146 Note that two operations are nested. You can obviously do it in two steps. Exercise 3.13 Create a vector representing the prices of groceries, bread $2.5, milk $3.1, jam $5.3, beer $9.1. And create a bar plot to represent this information. 3.2.2 Matrix operations Matrix is a two dimensional data structure in R programming. Technically, a matrix is also a vector, but with two additional attributes: the number of rows and the number of columns. A matrix has rows and columns, but it can only contain one type of values, i.e. numbers, characters, or logical values. We can creat a matrix by using rbind or cbind function. rbind combine all row Here are two examples: m &lt;- rbind(c(3, 4, 5), c(10, 13, 15)) # combine vectors by row m ## [,1] [,2] [,3] ## [1,] 3 4 5 ## [2,] 10 13 15 n &lt;- cbind(c(3, 4, 5), c(10, 13, 15), c(3, 2, 1)) # combine vectors by column n ## [,1] [,2] [,3] ## [1,] 3 10 3 ## [2,] 4 13 2 ## [3,] 5 15 1 s &lt;- rbind(m,n) #combine two matrices m and n by row s ## [,1] [,2] [,3] ## [1,] 3 4 5 ## [2,] 10 13 15 ## [3,] 3 10 3 ## [4,] 4 13 2 ## [5,] 5 15 1 To use rbind() combining matrices by row, the matrices must have same number of columns. Similar to cbind(), the matrices must have same number of rows. We can also create a matrix by using the matrix() function: x &lt;- matrix(seq(1:12), nrow = 4, ncol = 3) x ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 The argument seq() create a sequence from 1 to 12, nrom() define the number of rows in the matrix, ncol() define the number of columns in the matrix. We don’t have to give both nrom() and ncol() since if one is provided, the other is inferred from length of the data. y &lt;- matrix(seq(1:12), nrow = 4) y ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 As we can see that, the matrix is filled in column-wise by default. If you want to fill a matrix by row-wise, add the byrow = TRUE to the argument: z &lt;- matrix(seq(1:12), nrow = 4, byrow = TRUE) # fill matrix row-wise z ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 ## [4,] 10 11 12 The following code will create an empty matrix y: w &lt;- matrix(nrow = 4, ncol = 3) w ## [,1] [,2] [,3] ## [1,] NA NA NA ## [2,] NA NA NA ## [3,] NA NA NA ## [4,] NA NA NA We can assign values to the matrix. For example, let’s assign the value 3 to the position at first row and first column and value 100 to position of the second row and third column: w[1,1] &lt;- 3 w[2,3] &lt;- 100 w ## [,1] [,2] [,3] ## [1,] 3 NA NA ## [2,] NA NA 100 ## [3,] NA NA NA ## [4,] NA NA NA We can also create a matrix from a vector by setting its dimension using function dim(). x &lt;- c(1, 5, 6, 9, 8, 10, 21, 15, 76) x ## [1] 1 5 6 9 8 10 21 15 76 class(x) ## [1] &quot;numeric&quot; dim(x) &lt;- c(3, 3) x ## [,1] [,2] [,3] ## [1,] 1 9 21 ## [2,] 5 8 15 ## [3,] 6 10 76 class(x) ## [1] &quot;matrix&quot; We can convert a non-matrix data set to a matrix using as.matrix() function. Take the data iris as an example. subset.iris &lt;- iris[1:10, 1:4] class(subset.iris) ## [1] &quot;data.frame&quot; The data structure of subset.iris is a data frame. The function as.matrix wii transfer a data frame to a matix. x &lt;- as.matrix(subset.iris) class(x) ## [1] &quot;matrix&quot; Various matrix operation can be applied in R. For example: x &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2) x ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 x^2 #Squared each element in x ## [,1] [,2] [,3] ## [1,] 1 9 25 ## [2,] 4 16 36 You can transform the matrix if you want, for the convenience of view and analysis. y &lt;- t(x) # transpose of x y ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 x %*% y # Matrix Multiplication ## [,1] [,2] ## [1,] 35 44 ## [2,] 44 56 #x - y # Matrix subtraction Error in x - y : non-conformable arrays The error reminders us that the matrices for subtraction must have same dimensions. y &lt;- matrix(rep(1, 6), nrow = 2) y ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 1 1 1 x - y ## [,1] [,2] [,3] ## [1,] 0 2 4 ## [2,] 1 3 5 We can produce a new matrix by each element is doubled and added 5 z &lt;- 2 * x + 5 z ## [,1] [,2] [,3] ## [1,] 7 11 15 ## [2,] 9 13 17 We can also get a logical matrix using logical code like: x &lt;- matrix(c(12, 34, 51, 27, 26, 10), ncol = 2) x &gt; 20 ## [,1] [,2] ## [1,] FALSE TRUE ## [2,] TRUE TRUE ## [3,] TRUE FALSE We can extract all TRUE results from x by using x[x&gt;20]. x[x &gt; 20] ## [1] 34 51 27 26 Similar we can define a vector with logical values, then apply it to x to get all TRUE values. log.vau &lt;- c(FALSE, TRUE, TRUE, TRUE, TRUE, FALSE) x[log.vau] ## [1] 34 51 27 26 Remember matrix is a vector, and filled by column-wise. Therefore the vector with logical values applies to x by column-wise order. Since matrix is a vector with two dimension, all operations for vectors also apply to matrix. For example: x[1, ] # Get the first row of x ## [1] 12 27 a &lt;- as.matrix(iris[, 1:4]) #Take out the first 4 columns of iris and convert it to matrix. c &lt;- a[5:10, 2:4] # Extract a subset c ## Sepal.Width Petal.Length Petal.Width ## [1,] 3.6 1.4 0.2 ## [2,] 3.9 1.7 0.4 ## [3,] 3.4 1.4 0.3 ## [4,] 3.4 1.5 0.2 ## [5,] 2.9 1.4 0.2 ## [6,] 3.1 1.5 0.1 x &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2) c[1:2, ] &lt;- x # Replace the first two rows of c with x c ## Sepal.Width Petal.Length Petal.Width ## [1,] 1.0 3.0 5.0 ## [2,] 2.0 4.0 6.0 ## [3,] 3.4 1.4 0.3 ## [4,] 3.4 1.5 0.2 ## [5,] 2.9 1.4 0.2 ## [6,] 3.1 1.5 0.1 Now if we want to know the mean and sum of these rows and columns, try rowMeans(), colMeans(), rowSums(), colSums(). x &lt;- as.matrix(iris[1:10, 1:4]) rowMeans(x) ## 1 2 3 4 5 6 7 8 9 10 ## 2.550 2.375 2.350 2.350 2.550 2.850 2.425 2.525 2.225 2.400 colMeans(x) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 4.86 3.31 1.45 0.22 rowSums(x) ## 1 2 3 4 5 6 7 8 9 10 ## 10.2 9.5 9.4 9.4 10.2 11.4 9.7 10.1 8.9 9.6 colSums(x) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 48.6 33.1 14.5 2.2 Here we are computing the standard deviation by columns, using apply() function.The second argument “1” or “2” in apply() reprents the function applies to rows or columns. apply(x, 2, sd) # Calculate the standard deviation of each column in x ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 0.29135698 0.30713732 0.10801234 0.07888106 Or median by rows, using 1 for rows. apply(x, 1, median) # Calculate the median of each row in x ## 1 2 3 4 5 6 7 8 9 10 ## 2.45 2.20 2.25 2.30 2.50 2.80 2.40 2.45 2.15 2.30 Heatmap is my favorite type of graph for visualizing a large matrix data. heatmap(x, scale = &quot;column&quot;, margins = c(10,5)) Exercise 3.14 Let subset.iris &lt;- as.matrix(iris[1:10, 1:4]), Using apply function to calculate the mean of subset.iris by column. Example: Define a function to find the positions of minimal value in each column of subset.iris &lt;- as.matrix(iris[1:10, 1:4]). find.min.posi &lt;- function(x){ y &lt;- function(xcol){ return(which.min(xcol)) } return(apply(x, 2, y)) } subset.iris &lt;- as.matrix(iris[1:10, 1:4]) subset.iris ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 ## 7 4.6 3.4 1.4 0.3 ## 8 5.0 3.4 1.5 0.2 ## 9 4.4 2.9 1.4 0.2 ## 10 4.9 3.1 1.5 0.1 find.min.posi(subset.iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 9 9 3 10 As you can see that the minimal value for Sepal.Length is 4.4 which locates at the 9th row. Similar to other variable. The minimal value locates at the 9th, 3rd and 10th row for Sepal.Width, Petal.Lenth and Petal.Width respectively. Exercise 3.15 Let subset.iris.2 &lt;- as.matrix(iris[, 1:4]), fill blanks in the find.max function defined below to find the maximal value in each column of subset.iris.2. find.max &lt;- function(x){ y &lt;- function(xcol){ return(_________) } return(_______(x, ____, y)) } ________(subset.iris.2) To make a matrix more easily readable, we can use functions colnames() and rownames to assign names to the columns and rows of the matrix. For example: y &lt;- rbind(c(1, 3, 5), c(2, 4, 6)) y ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 colnames(y) &lt;- c(&#39;First.Col&#39;, &#39;Second.Col&#39;, &#39;Third.Col&#39;) row.names(y) &lt;- c(&#39;odd.number&#39;, &#39;even.number&#39;) y ## First.Col Second.Col Third.Col ## odd.number 1 3 5 ## even.number 2 4 6 Another interesting application of matrix is the manipulation of images.You may have heard pixel matrix which represents “picure elements”. They are small little dots making up images. Each image is a matrix with thousands or even millions of pixels. Each pixel can only be one color at a time. If we have a grayscale imge, the brightness of color for each pixel is determined by the value assigned to it. In other words, the pixel value is a single number that represents the brightness of the pixel. For example, if the color value 0.2941 is assigned to a pixel which locates 3rd row and 4th column, then the image at 3rd row and 4th column is pretty dark. The range of the colors from black to white correspond to the scale varies from 0% to 100%. Most time, we need to blur images or add mosaic to a picture for various purposes. Let’s use one example to demonstrate how to add mosaic to a grayscale image. Example: Add mosaic to Einstein image Firstly, let’s read an grayscale image of Einstein into R and view the image. library(pixmap) ## Warning: package &#39;pixmap&#39; was built under R version 3.5.2 EINSTEIN &lt;- read.pnm(&quot;EINSTEIN.pgm&quot;, cellres = 1) plot(EINSTEIN) Then let us look at structure of this image: str(EINSTEIN) ## Formal class &#39;pixmapGrey&#39; [package &quot;pixmap&quot;] with 6 slots ## ..@ grey : num [1:512, 1:512] 0.596 0.541 0.522 0.529 0.561 ... ## ..@ channels: chr &quot;grey&quot; ## ..@ size : int [1:2] 512 512 ## ..@ cellres : num [1:2] 1 1 ## ..@ bbox : num [1:4] 0 0 512 512 ## ..@ bbcent : logi FALSE Here we get a new class which is S4 type. We don’t go into depth for this time. One fact we need to pay attendtion is that we must use “@” instead of “$” sign to designate the components. class(EINSTEIN@ grey) ## [1] &quot;matrix&quot; The class of EINSTEIN@ grey is matrix. The output ..@ grey : num [1:512, 1:512] shows that the dimension of matrix is 512*512. The values “0.596 0.541 0.522 0.529 0.561 …” reprent the brightness values in the matrix. For example, the value of the pixel at 3rd row and 4th column is 0.2941176 as showed below: EINSTEIN@ grey[3,4] ## [1] 0.2941176 If we change the value 0.2941176 to 0 by EINSTEIN@ grey[3,4] &lt;- 0, then that pixel will become pure black. If we assign a random number between 0 to 1 to the value, then the color in the pixel will be randomly assigned based on the random number. Using this idea, we define a masoic function which will be used to blur the image. mosaic.plot &lt;- function(image, yrange, xrange){ length.y &lt;- length(yrange) length.x &lt;- length(xrange) image2 &lt;- image whitenoise &lt;- matrix(nrow = length.y, ncol = length.x, runif(length.y * length.x)) image2@grey[yrange, xrange] &lt;- whitenoise return(image2) } The argument image is the original image, yrange is the range of rows that you want to blur, xrange is the range of columns that you want to blur. The xrange and yrange construct the mosaic region. Since we don’t want to change the origial image,therefore we copy the original image to image2 by assigning image to image2. The whitenoise creates a matrix filled with random numbers following uniform distribution. The dimensions of whitenoise is determined by the mosaic region. Replace the values in the original image that you want to blur image2@grey[yrange,xrange] by the whitenoise matrix. EINSTEIN.mosaic &lt;- mosaic.plot(EINSTEIN, 175:249, 118:295) plot(EINSTEIN.mosaic) Here, we take yrange=175:249 and xrange=118:295 to select a sub-matrix from 175th row to 249th row, and 118th column to 295th column. This sub-matrix store the color values of Einstein’ eyes region. The sub-matix is replaced by whitenoise matrix. Therefore the image near eyes region are replaced by random colors. The function locator() allows us to find the relevant rows and columns. Type locator() in the Console window, then R will wait for you to click a point within an image, then click esc on your keyboard to exit the function. Then the function will return the coordinates of that point in the Console window. If you click more points once, then the function will return all coordinates of these points sorted by your clicking order. You must be careful about the y-coordinate. The row numbers in pixmap objects increase from the top of the image to the bottom, therefore you need to opposite the y-coordinate by subtracting them from the number of rows in the original image. For example, the y-coordinates that I obtained from locator() function are 337 and 263. After subtracting them from 512, I got 175 and 249. They are the yrange used in the mosaic function. Exercise 3.16 Using the mosaic.plot() function to blur the image of mona_lisa.pgm by adding mosaic to her eyes region. Your output should look like the graph below. Exercise 3.17 Fill in blanks of the following function so that the eyes region of Mona Lisa is covered by pure color, not mosaic. mosaic.plot.2 &lt;- function(picture, yrange, xrange, degree){ length.y &lt;- _______(yrange) length.x &lt;- length(______) pic2 &lt;- picture pic2@____[_______,_______] &lt;- degree return(pic2) } Setting the degree=0, 0.5 and 1 respectively, plot the images of Mona Lisa that eyes region are covered by pure colors. 3.2.3 Lists All elements in vectors must be same type. The list can combine objectes of different types. Let’s start from creating a list: y &lt;- list(5, &quot;John Doe&quot;, c(100, 7), mean) # a list with 4 components y ## [[1]] ## [1] 5 ## ## [[2]] ## [1] &quot;John Doe&quot; ## ## [[3]] ## [1] 100 7 ## ## [[4]] ## function (x, ...) ## UseMethod(&quot;mean&quot;) ## &lt;bytecode: 0x000000001e8a5670&gt; ## &lt;environment: namespace:base&gt; There are 4 components in the list y. We can associate each components with a tag. We add tags “height”, “name”, “BP” and “fun” to the y. y &lt;- list(height = 5, name = &quot;John Doe&quot;, BP = c(100, 77), fun = mean) y ## $height ## [1] 5 ## ## $name ## [1] &quot;John Doe&quot; ## ## $BP ## [1] 100 77 ## ## $fun ## function (x, ...) ## UseMethod(&quot;mean&quot;) ## &lt;bytecode: 0x000000001e8a5670&gt; ## &lt;environment: namespace:base&gt; Here is another example for creating a list: x1 &lt;- matrix(c(4, 2, 5, 6, 10, 9), ncol = 3) # create a matrix x2 &lt;- 8 : 1 x3 &lt;- c(2.4, 5.1, 9.0, 4.4) x4 &lt;- c(&#39;u&#39;, &#39;v&#39;, &#39;w&#39;) z &lt;- list(x1, x2, x3, x4) z ## [[1]] ## [,1] [,2] [,3] ## [1,] 4 5 10 ## [2,] 2 6 9 ## ## [[2]] ## [1] 8 7 6 5 4 3 2 1 ## ## [[3]] ## [1] 2.4 5.1 9.0 4.4 ## ## [[4]] ## [1] &quot;u&quot; &quot;v&quot; &quot;w&quot; We can build a list by creating an empty list and assigning values to it. v &lt;- list() #Create an empty list v[[1]] &lt;- matrix(c(4, 2, 5, 6, 10, 9), ncol = 3) # Assign a matrix to v[[1]] v[[2]] &lt;- 8 : 1 #Assign a vector to v[[2]] v[[3]] &lt;- x3 #Assign x3 to v[[3]] where x3 is defined as above v[[4]] &lt;- x4 #Assign x4 to v[[4]] where x4 is defined as above v ## [[1]] ## [,1] [,2] [,3] ## [1,] 4 5 10 ## [2,] 2 6 9 ## ## [[2]] ## [1] 8 7 6 5 4 3 2 1 ## ## [[3]] ## [1] 2.4 5.1 9.0 4.4 ## ## [[4]] ## [1] &quot;u&quot; &quot;v&quot; &quot;w&quot; We used different methods creating list z and v. The list v and z are identical because that we assigned same components for v as that of in z. There are several different ways to access the elements in a list. For example, to access the third component in y: y &lt;- list(height = 5, name = &quot;John Doe&quot;, BP = c(100, 77), fun = mean) y[[3]] #Specifing the number in a double square braket ## [1] 100 77 y$BP #Using $ sign ## [1] 100 77 y[[&quot;BP&quot;]] #Using the tag ## [1] 100 77 Note: we used double square braket ‘[[]]’ to access the element in a list, which is different from using single square braket ‘[]’ in a vector. If we use sigle square braket in a list, we will get a sublist. For example, y[3] returns a list, y[[3]] returns a numerical vector. Functions class() and is.list can be used to check the types. y[3] ## $BP ## [1] 100 77 class(y[3]) ## [1] &quot;list&quot; is.list(y[3]) ## [1] TRUE y[[3]] ## [1] 100 77 class(y[[3]]) #Get the class of y[[3]] ## [1] &quot;numeric&quot; is.list(y[[3]]) #Check if y[[3]] is a list or not ## [1] FALSE The forth component of y is fun = mean. There are no quotation marks around mean. The class(y[[4]]) returns a function. class(y[[4]]) ## [1] &quot;function&quot; This implies that y[[4]] is same as the mean() function. For example: y[[4]](c(1, 2, 3, 4, 5)) #Get the mean of 1, 2, 3, 4, 5 ## [1] 3 Exercise 3.18 Access the second component in list1 by three ways as we introduced above. What is the type of list1[“Hobby”] and list1[[“Hobby”]] respectively? list1 &lt;- list(Name = &quot;Tom&quot;, Hobby = &quot;Fishing&quot;, Num.fish = c(16, 27, 5)) Here are some examples for list operation: y &lt;- list(height = 5, name = &quot;John Doe&quot;, BP = c(100, 77), fun = mean) y[[2]] &lt;- &quot;Mike&quot; #Change the 2nd component from &quot;John Doe&quot; to &quot;Mike&quot; y[[4]] &lt;- NULL #Delete the 4th component by setting it to NULL y ## $height ## [1] 5 ## ## $name ## [1] &quot;Mike&quot; ## ## $BP ## [1] 100 77 The output shows that the name has been changed to Mike and the mean function is deleted. So far, the length of y is 3: length(y) ## [1] 3 We can add the forth components to y using the following code: y$class &lt;- c(&quot;math&quot;, &quot;art&quot;) #Add a class component y ## $height ## [1] 5 ## ## $name ## [1] &quot;Mike&quot; ## ## $BP ## [1] 100 77 ## ## $class ## [1] &quot;math&quot; &quot;art&quot; If we have a vector of tags and a vector of corresponding values, we can associate the names and values into a list by creating an empty list and then fill it via assignment statements: sales &lt;- c(100, 105, 98, 112) seasons &lt;- c(&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;) sale.tag &lt;- list() #Create an empty list sale.tag[seasons] &lt;- sales sale.tag ## $Spring ## [1] 100 ## ## $Summer ## [1] 105 ## ## $Fall ## [1] 98 ## ## $Winter ## [1] 112 Equivalently, we can associate the names and values by creating an empty list and then assign each component corresponding value or vector. For example. sale.tag &lt;- list() #Create an empty list sale.tag[[&quot;Spring&quot;]] &lt;- 100 sale.tag[[&quot;Summer&quot;]] &lt;- 105 sale.tag[[&quot;Fall&quot;]] &lt;- 98 sale.tag[[&quot;Winter&quot;]] &lt;- 112 sale.tag ## $Spring ## [1] 100 ## ## $Summer ## [1] 105 ## ## $Fall ## [1] 98 ## ## $Winter ## [1] 112 Exercise 3.19 Based on the data set of sale.tag, choose all correct answers from the following options A - F. A: sale.tag[[1]] B: sale.tag[[Spring]] C: sale.tag[[“Spring”]] D: sale.tag[“Spring”] E: sale.tag[1] F: sale.tag[Spring] 1, Which options return a vector. Answer:___________ 2, Which options return a list. Answer:___________ 3, Which options returns an error. Answer:___________ Suppose we want to calculate the mean of sales in the dataset sale.tag. Because basic statistical functions work on vectors but not on lists. The mean() does not work: &gt; mean(sale.tag) [1] NA Warning message: In mean.default(sale.tag) : argument is not numeric or logical: returning NA To calculate the mean, we need to use function unlist() to flatten the list into a vector. mean(unlist(sale.tag)) ## [1] 103.75 Similar to apply() funciton works on vectors, lapply() (for list apply) works on each component of lists. Here is an example: x &lt;- list(c(10, 20, 30), c(4, 5, 6, 7, 8)) mean.x &lt;- lapply(x, mean) mean.x ## [[1]] ## [1] 20 ## ## [[2]] ## [1] 6 The mean.x returns a list consisting of 20 and 6 which are means of components of x respectively. When the list returned by lapply() could be simplified to a vector or matrix, we can use function sapply() (for simplified [l]apply). Let’s redo the previous example by sapply() function. mean.x.2 &lt;- sapply(x, mean) mean.x.2 ## [1] 20 6 We can double check the outputs by class() or is.vector() function: class(mean.x) ## [1] &quot;list&quot; class(mean.x.2) ## [1] &quot;numeric&quot; is.vector(mean.x.2) ## [1] TRUE Here is another example for sapply() function. Suppose we have NULL elements in a list.null. To remove the NULL element, apply is.null function to every element of the list.null. If the logical value is TRUE, i.e. the element is a NULL, then delete the element by setting NULL to it. list.null &lt;- list(&#39;art&#39;, NULL, c(2, 4, 6, 8)) list.null ## [[1]] ## [1] &quot;art&quot; ## ## [[2]] ## NULL ## ## [[3]] ## [1] 2 4 6 8 list.null[sapply(list.null, is.null)] &lt;- NULL list.null ## [[1]] ## [1] &quot;art&quot; ## ## [[2]] ## [1] 2 4 6 8 For a small size data set, if we can locate the position of NULL element, we can easily remove the NULL element by setting NULL to that element. For example, we already know the second element of list.null is NULL, to remove this NULL element, we set a NULL to the second element: list.null &lt;- list(&#39;art&#39;, NULL, c(2, 4, 6, 8)) list.null[[2]] &lt;- NULL list.null ## [[1]] ## [1] &quot;art&quot; ## ## [[2]] ## [1] 2 4 6 8 But for large size of data set, we turn to the sapply() function to remove NULL elements. Example: Suppose we have a list of customers who visited our store in the last 10 days. Some customers visited the store more than once. We want to find out on which days and the total number of days that each customer visited. The customer names are recorded by the order of the day they came: customer &lt;- list(&quot;Alex&quot;, &quot;Brandon&quot;, &quot;Alex&quot;, &quot;Daniel&quot;, &quot;Grace&quot;, &quot;Mary&quot;, &quot;Mary&quot;, &quot;Alex&quot;, &quot;Tom&quot;, &quot;Grace&quot;) Firsly, we define a function which returns all locations of same elements in a list. loc.names &lt;- function(f){ y &lt;- unlist(f) # Flatten a list x into a vector y x &lt;- list() # Create an empty list for (i in 1:length(y)){ c.name &lt;- y[i] # Assign the ith element to c.name. x[[c.name]] &lt;- c(x[[c.name]],i) # assign values to x[[c.name]]. c.name is the name of x. } return(x) } the f will be replaced by your own list. In this example, f will be replaced by the list of customer when we apply the funtion. x &lt;- list () # create an empty list. In the for loop, i starts from 1 to the length of y. In our example, the length of y is the length of list of customers: 10. c.name &lt;- y[i] # Assign the ith element in y to a new variable c.name. For example, if i=1, y[1] is the “Alex”, then c.name = “Alex”. x[[c.name]] &lt;- c(x[[c.name]], i) For i=1, we have c.name &lt;- “Alex”, then x[[c.name]] = x[[“Alex”]] = NULL since x starting from an empty list. Therefore c(x[[“Alex”]], i) = c(NULL, i) = i = 1. The value 1 will be assigned to x[[“Alex”]] by the code: x[[“Alex”]] &lt;- c(x[[“Alex”]], i) = 1. Now x is not an empty list, it is a list with 1 component: x &lt;- list() x[[&quot;Alex&quot;]] &lt;- 1 x ## $Alex ## [1] 1 For i=2, y[2] &lt;- “Brandon”, then similar to the case of i=1, we have x[[“Brandon”]] &lt;- 1: x[[&quot;Brandon&quot;]] &lt;- 1 x ## $Alex ## [1] 1 ## ## $Brandon ## [1] 1 For i=3, y[3] &lt;- “Alex”. We have met “Alex” once, which returned x[[“Alex”]] &lt;- 1. Now we meet “Alex” again which means we are going to update x[[“Alex”]] by x[[“Alex”]] &lt;- c(x[[“Alex”]], i) = c(1, i) = c(1, 3). The updated x is: x[[&quot;Alex&quot;]] &lt;- c(1, 3) x ## $Alex ## [1] 1 3 ## ## $Brandon ## [1] 1 The process will stop till i = length (y) = 10. The loc.names() funciton will return all locations of all names which are already stored in x. Let’s find all days of cumsters who visited to our store. customer &lt;- list(&quot;Alex&quot;, &quot;Brandon&quot;, &quot;Alex&quot;, &quot;Daniel&quot;, &quot;Grace&quot;, &quot;Mary&quot;, &quot;Mary&quot;, &quot;Alex&quot;, &quot;Tom&quot;, &quot;Grace&quot;) v1 &lt;- loc.names(customer) v1 ## $Alex ## [1] 1 3 8 ## ## $Brandon ## [1] 2 ## ## $Daniel ## [1] 4 ## ## $Grace ## [1] 5 10 ## ## $Mary ## [1] 6 7 ## ## $Tom ## [1] 9 The output tells us that Alex visited our store at the first, third and eighth days, Brandon came at the second day, etc. Then we use sapply() function to calculate the repeat times of each element. v2 &lt;- sapply(v1,length) # Calculate the length of each component in v1 v2 ## Alex Brandon Daniel Grace Mary Tom ## 3 1 1 2 2 1 You can sort the v2 by the number of days that they presented by function sort(): sort(v2, decreasing = T) ## Alex Grace Mary Brandon Daniel Tom ## 3 2 2 1 1 1 Exercise 3.20 Fill blanks in the function my.fun() so that for a given list, the function returns all locations of each element and sort the frequency of the elements in an increasing order. Then apply my.fun() to a set of gender: F F M M M M I I F I F M I F M I I M I I F Where F, M and I represent Female, Male and Infant respectively. my.fun &lt;- function(f){ y &lt;- unlist(f) x &lt;- ___________ for (i in 1:____){ g1 &lt;- y[i] x[[______]] &lt;- c(x[[____]],i) } freq &lt;- _________(x, length) z &lt;- sort(________, decreasing = ____) lst &lt;- list(x, z) ___________(lst) } gender &lt;- list( “F”, ________________________________, “F”) __________(gender) # Many R functions, such as t.test(), returns results as a list, which contain a series of components, such as a P value, a vector of residuals or coefficients, and even a matrix of data. A list is the natural way to represent this sort of thing as one big object that could be parsed. r1 &lt;- rnorm(100) # Create 100 random numbers following Normal Distribution r2 &lt;- rnorm(100) t.result &lt;- t.test(r1, r2) # Run the t test. Test if the mean of r1 and r2 are same. is.list(t.result) # Check if the t.result is a list ## [1] TRUE t.result # A list holds all components of t-test ## ## Welch Two Sample t-test ## ## data: r1 and r2 ## t = 0.091317, df = 192.25, p-value = 0.9273 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -0.2586149 0.2837241 ## sample estimates: ## mean of x mean of y ## 0.07675548 0.06420091 names(t.result) # Returns all tags of the t test result ## [1] &quot;statistic&quot; &quot;parameter&quot; &quot;p.value&quot; &quot;conf.int&quot; &quot;estimate&quot; ## [6] &quot;null.value&quot; &quot;alternative&quot; &quot;method&quot; &quot;data.name&quot; t.result$p.value # Retrieves p-value for the test ## [1] 0.9273358 t.result$estimate # Returns mean of r1 and r2 ## mean of x mean of y ## 0.07675548 0.06420091 The help page of t.test contains information about what types of values are returned and their names. ? t.test Let’s run a simulation using a loop. What we want to do is to generate two sets of 100 random numbers from the standard normal distribution with zero mean and unit standard deviation, and perform t-test and get the p value. By repeating this process 500 times, we want to see the distribution of p values and count how many times we get significant result with p &lt; 0.05. pvalues &lt;- rep(1, 500) # define a vector containing 500 numbers, all equal to 1. for (i in 1:500) { # Loop: The values of i takes values from 1,2,3, …, 500 result = t.test(rnorm(100), rnorm(100)) pvalues[i] = result$p.value # P values are stored in the i-th element in the vector } hist(pvalues) # Histogram of p-values summary(pvalues) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.001481 0.244823 0.522116 0.506093 0.750378 0.998808 sum(pvalues &lt; 0.05) # Number of p-value&#39;s which are less than 0.05. ## [1] 24 3.2.4 Strings and string vectors We encounter text data sometimes. Plus, we also have row and column names. We can easily manipulate these string objects. Define a string x: “R is cool” x &lt;- &quot;R is cool&quot; If we want to know the number of character of the string: nchar(x) ## [1] 9 We can concatenate strings. By default a space is added. paste(x, &quot;!!&quot;) ## [1] &quot;R is cool !!&quot; If we want to extract sub-string from position of 6 and 9: substr(x, 6, 9) ## [1] &quot;cool&quot; Split string into a list which is separated by space: strsplit(x, &quot; &quot;) ## [[1]] ## [1] &quot;R&quot; &quot;is&quot; &quot;cool&quot; Find pattern “R” and replace with “Tim”: gsub(&quot;R&quot;, &quot;Tim&quot;, x) ## [1] &quot;Tim is cool&quot; Or remove space followed by anything: gsub(&quot; .*&quot;, &quot;&quot;, x) ## [1] &quot;R&quot; We can search for pattern like “is” in the string. grepl(&quot;is&quot;, x) ## [1] TRUE We can also convert the whole string into low case or upper case by “tolower” or “toupper” function. tolower(x) ## [1] &quot;r is cool&quot; toupper(x) ## [1] &quot;R IS COOL&quot; A string vector can hold many strings. This can be a column of names or IDs in a table. First let’s define a character vector x &lt;- c(“ab”, “cde”, “d”, “ab”). x &lt;- c(&quot;ab&quot;, &quot;cde&quot;, &quot;d&quot;, &quot;ab&quot;) We can use all commands about vector for our string vector, such as 2nd element in vector: x[2] ## [1] &quot;cde&quot; Number of strings in the vector: length(x) ## [1] 4 Unique elements: unique(x) ## [1] &quot;ab&quot; &quot;cde&quot; &quot;d&quot; Now we are interested in the duplicated element in the string vector. Is there any duplicated element in the vector? duplicated(x) ## [1] FALSE FALSE FALSE TRUE The last element is duplicated. F denotes FALSE, and T for TRUE. If we want to know the number of characters in each of the element: nchar(x) ## [1] 2 3 1 2 We can also unite two vectors x and y if we define another vector y first: y &lt;- c(&quot;ab&quot;, &quot;e&quot;) union(x, y) ## [1] &quot;ab&quot; &quot;cde&quot; &quot;d&quot; &quot;e&quot; Is there intercept among these two sets of strings? intersect(x, y) ## [1] &quot;ab&quot; We can add something like “Q” to each element: paste(x, &quot;Q&quot;) ## [1] &quot;ab Q&quot; &quot;cde Q&quot; &quot;d Q&quot; &quot;ab Q&quot; To get rid of the space between these element and “Q”, try paste0: paste0(x, &quot;Q&quot;) ## [1] &quot;abQ&quot; &quot;cdeQ&quot; &quot;dQ&quot; &quot;abQ&quot; If we want to collapse multiple strings into one, which is joined by space: paste(x, collapse = &quot; &quot;) ## [1] &quot;ab cde d ab&quot; Using these functions, we can achieve many things. For example if we have a piece of DNA sequence: DNA &lt;- &quot;taaCCATTGtaaGAACATGGTTGTCcaaaCAAGATGCTAGT&quot; Note that I am using the assignment operator “&lt;-”, instead of “=”, which also works most of the times but it could be ambiguous. First we need to convert everything to upper case. DNA &lt;- toupper(DNA) Next, we want to cut this DNA into smaller pieces by looking for a certain pattern “ATG”. This type of thing happens in nature, as some enzymes cut DNA according to certain pattern. segs &lt;- strsplit(DNA, &quot;ATG&quot;) The result is contained in an object segs, which is a list. We needed the unlist( ) function to convert list to a string vector. segs &lt;- unlist(segs) segs # a vector of strings ## [1] &quot;TAACCATTGTAAGAAC&quot; &quot;GTTGTCCAAACAAG&quot; &quot;CTAGT&quot; segs[1] # first segment ## [1] &quot;TAACCATTGTAAGAAC&quot; Exercise 3.21 In the iris flower dataset iris, define a new column called FullName which contains the full species name by adding “Iris“ in front of species name. In other words, “setosa” should become “Iris setosa”, “virginica” would be “Iris virginica”, and “versicolor” needs to be “Iris versicolor”. 3.2.5 Operations on data frames Once data is read in as data frame, these are commands you can use to analyze it. Read in data frame x: x &lt;- iris Using summary() we can get descriptive statistics of each column. summary(x) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## head() and tail() functions show the fist and last few rows. head(x) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa tail(x) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica If we want to know both number of rows and number of columns of the data frame: dim(x) ## [1] 150 5 We can just get number of rows or number of columns separately: nrow(x) ## [1] 150 ncol(x) ## [1] 5 If we are interested in the column names or row names, which should be a vector of strings: colnames(x) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; ## [5] &quot;Species&quot; rownames(x) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; ## [12] &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; ## [23] &quot;23&quot; &quot;24&quot; &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; ## [34] &quot;34&quot; &quot;35&quot; &quot;36&quot; &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; ## [45] &quot;45&quot; &quot;46&quot; &quot;47&quot; &quot;48&quot; &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; ## [56] &quot;56&quot; &quot;57&quot; &quot;58&quot; &quot;59&quot; &quot;60&quot; &quot;61&quot; &quot;62&quot; &quot;63&quot; &quot;64&quot; &quot;65&quot; &quot;66&quot; ## [67] &quot;67&quot; &quot;68&quot; &quot;69&quot; &quot;70&quot; &quot;71&quot; &quot;72&quot; &quot;73&quot; &quot;74&quot; &quot;75&quot; &quot;76&quot; &quot;77&quot; ## [78] &quot;78&quot; &quot;79&quot; &quot;80&quot; &quot;81&quot; &quot;82&quot; &quot;83&quot; &quot;84&quot; &quot;85&quot; &quot;86&quot; &quot;87&quot; &quot;88&quot; ## [89] &quot;89&quot; &quot;90&quot; &quot;91&quot; &quot;92&quot; &quot;93&quot; &quot;94&quot; &quot;95&quot; &quot;96&quot; &quot;97&quot; &quot;98&quot; &quot;99&quot; ## [100] &quot;100&quot; &quot;101&quot; &quot;102&quot; &quot;103&quot; &quot;104&quot; &quot;105&quot; &quot;106&quot; &quot;107&quot; &quot;108&quot; &quot;109&quot; &quot;110&quot; ## [111] &quot;111&quot; &quot;112&quot; &quot;113&quot; &quot;114&quot; &quot;115&quot; &quot;116&quot; &quot;117&quot; &quot;118&quot; &quot;119&quot; &quot;120&quot; &quot;121&quot; ## [122] &quot;122&quot; &quot;123&quot; &quot;124&quot; &quot;125&quot; &quot;126&quot; &quot;127&quot; &quot;128&quot; &quot;129&quot; &quot;130&quot; &quot;131&quot; &quot;132&quot; ## [133] &quot;133&quot; &quot;134&quot; &quot;135&quot; &quot;136&quot; &quot;137&quot; &quot;138&quot; &quot;139&quot; &quot;140&quot; &quot;141&quot; &quot;142&quot; &quot;143&quot; ## [144] &quot;144&quot; &quot;145&quot; &quot;146&quot; &quot;147&quot; &quot;148&quot; &quot;149&quot; &quot;150&quot; str() is a very useful function, which shows data types for all columns. str(x) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Like string and vector, we can select one element in the data frame, like element in 2nd row and 3rd column. x[2, 3] ## [1] 1.4 Also we can subset a smaller data frame from x, such as columns 2 to 4 and rows 1 to 10: x[1:10, 2:4] ## Sepal.Width Petal.Length Petal.Width ## 1 3.5 1.4 0.2 ## 2 3.0 1.4 0.2 ## 3 3.2 1.3 0.2 ## 4 3.1 1.5 0.2 ## 5 3.6 1.4 0.2 ## 6 3.9 1.7 0.4 ## 7 3.4 1.4 0.3 ## 8 3.4 1.5 0.2 ## 9 2.9 1.4 0.2 ## 10 3.1 1.5 0.1 We can only retrieve all of the first column: x[, 1] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 Using the data frame name x followed column name has the same effect. x$Sepal.Length ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 ## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 ## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 ## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 ## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 ## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 ## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 ## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 ## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9 If we need to know the average Sepal Length, we use mean() function. By the way, expressions can be nested. mean(x$Sepal.Length) ## [1] 5.843333 It’s very common to select a subset of data by certain column. Note “==” is for comparison and “=” is for assign value. Also you can use logical symbols like “&gt;” ,“&lt;”. y &lt;- subset(x, Species == &quot;setosa&quot;) head(y) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa subset(x, Sepal.Length &gt; 7) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 103 7.1 3.0 5.9 2.1 virginica ## 106 7.6 3.0 6.6 2.1 virginica ## 108 7.3 2.9 6.3 1.8 virginica ## 110 7.2 3.6 6.1 2.5 virginica ## 118 7.7 3.8 6.7 2.2 virginica ## 119 7.7 2.6 6.9 2.3 virginica ## 123 7.7 2.8 6.7 2.0 virginica ## 126 7.2 3.2 6.0 1.8 virginica ## 130 7.2 3.0 5.8 1.6 virginica ## 131 7.4 2.8 6.1 1.9 virginica ## 132 7.9 3.8 6.4 2.0 virginica ## 136 7.7 3.0 6.1 2.3 virginica We also can add new column named “id” to the data frame, which goes from 1 to 150. Function head() is used to examine. x$id &lt;- 1:150 head(x) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species id ## 1 5.1 3.5 1.4 0.2 setosa 1 ## 2 4.9 3.0 1.4 0.2 setosa 2 ## 3 4.7 3.2 1.3 0.2 setosa 3 ## 4 4.6 3.1 1.5 0.2 setosa 4 ## 5 5.0 3.6 1.4 0.2 setosa 5 ## 6 5.4 3.9 1.7 0.4 setosa 6 cbind() is for adding another exist column, like a column of random numbers y. y &lt;- rnorm(150) x2 &lt;- cbind(x, y) head(x2) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species id y ## 1 5.1 3.5 1.4 0.2 setosa 1 1.41675954 ## 2 4.9 3.0 1.4 0.2 setosa 2 0.10033205 ## 3 4.7 3.2 1.3 0.2 setosa 3 0.66310771 ## 4 4.6 3.1 1.5 0.2 setosa 4 -0.17284595 ## 5 5.0 3.6 1.4 0.2 setosa 5 0.56462774 ## 6 5.4 3.9 1.7 0.4 setosa 6 0.08538086 Similar as cbind(), rbind() is for adding another exist row or rows with same length of columns. Now we use tail() to examine. newRow &lt;- c(1, 1, 1, 1, &quot;setosa&quot;, 151) x3 &lt;- rbind(x, newRow) tail(x3) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species id ## 146 6.7 3 5.2 2.3 virginica 146 ## 147 6.3 2.5 5 1.9 virginica 147 ## 148 6.5 3 5.2 2 virginica 148 ## 149 6.2 3.4 5.4 2.3 virginica 149 ## 150 5.9 3 5.1 1.8 virginica 150 ## 151 1 1 1 1 setosa 151 We can sort the data frame by certain column. For example we need to sort first column in ascending, or to sort second column in descending order. y &lt;- x[order(x[, 1]), ] head(y) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species id ## 14 4.3 3.0 1.1 0.1 setosa 14 ## 9 4.4 2.9 1.4 0.2 setosa 9 ## 39 4.4 3.0 1.3 0.2 setosa 39 ## 43 4.4 3.2 1.3 0.2 setosa 43 ## 42 4.5 2.3 1.3 0.3 setosa 42 ## 4 4.6 3.1 1.5 0.2 setosa 4 y &lt;- x[rev(order(x[, 2])), ] head(y) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species id ## 16 5.7 4.4 1.5 0.4 setosa 16 ## 34 5.5 4.2 1.4 0.2 setosa 34 ## 33 5.2 4.1 1.5 0.1 setosa 33 ## 15 5.8 4.0 1.2 0.2 setosa 15 ## 17 5.4 3.9 1.3 0.4 setosa 17 ## 6 5.4 3.9 1.7 0.4 setosa 6 We can view sepal length by species using boxplot. boxplot(Sepal.Length ~ Species, x) Or compute summary statistics by category, here average by species: aggregate(. ~ Species, x, mean) ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width id ## 1 setosa 5.006 3.428 1.462 0.246 25.5 ## 2 versicolor 5.936 2.770 4.260 1.326 75.5 ## 3 virginica 6.588 2.974 5.552 2.026 125.5 It is easier to conduct statistical analysis after organizing data as data frame. Analysis of variance, or ANOVA tests whether sepal length is the same cross species in data frame x. m &lt;- aov(Sepal.Length ~ Species, x) summary(m) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Species 2 63.21 31.606 119.3 &lt;2e-16 *** ## Residuals 147 38.96 0.265 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Regression analysis use linear model(lm) to analyze the relationship of these columns. Here we use sepal length as a function of sepal width and petal length plus error. m &lt;- lm(Sepal.Length ~ Sepal.Width + Petal.Length, x) summary(m) ## ## Call: ## lm(formula = Sepal.Length ~ Sepal.Width + Petal.Length, data = x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.96159 -0.23489 0.00077 0.21453 0.78557 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.24914 0.24797 9.07 7.04e-16 *** ## Sepal.Width 0.59552 0.06933 8.59 1.16e-14 *** ## Petal.Length 0.47192 0.01712 27.57 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3333 on 147 degrees of freedom ## Multiple R-squared: 0.8402, Adjusted R-squared: 0.838 ## F-statistic: 386.4 on 2 and 147 DF, p-value: &lt; 2.2e-16 We use data.frame() function to define a new data frame with 100 rows and two columns, ids and rand. y &lt;- data.frame(id = 1:100, rand = rnorm(100)) head(y) ## id rand ## 1 1 -0.23101297 ## 2 2 0.55162536 ## 3 3 0.09864152 ## 4 4 -1.38901114 ## 5 5 -0.52979468 ## 6 6 0.93171958 tail(y) ## id rand ## 95 95 0.30621802 ## 96 96 -0.07853044 ## 97 97 0.41654070 ## 98 98 -0.29365181 ## 99 99 -1.34123929 ## 100 100 0.62258938 Now we merge two data frames x and y by a common column called ids. Note the new data frame has only 100 rows. We can also merge data frame by row names too. z &lt;- merge(x, y, by = &quot;id&quot;) head(z) ## id Sepal.Length Sepal.Width Petal.Length Petal.Width Species rand ## 1 1 5.1 3.5 1.4 0.2 setosa -0.23101297 ## 2 2 4.9 3.0 1.4 0.2 setosa 0.55162536 ## 3 3 4.7 3.2 1.3 0.2 setosa 0.09864152 ## 4 4 4.6 3.1 1.5 0.2 setosa -1.38901114 ## 5 5 5.0 3.6 1.4 0.2 setosa -0.52979468 ## 6 6 5.4 3.9 1.7 0.4 setosa 0.93171958 summary(z) ## id Sepal.Length Sepal.Width Petal.Length ## Min. : 1.00 Min. :4.300 Min. :2.000 Min. :1.000 ## 1st Qu.: 25.75 1st Qu.:5.000 1st Qu.:2.800 1st Qu.:1.500 ## Median : 50.50 Median :5.400 Median :3.050 Median :2.450 ## Mean : 50.50 Mean :5.471 Mean :3.099 Mean :2.861 ## 3rd Qu.: 75.25 3rd Qu.:5.900 3rd Qu.:3.400 3rd Qu.:4.325 ## Max. :100.00 Max. :7.000 Max. :4.400 Max. :5.100 ## Petal.Width Species rand ## Min. :0.100 setosa :50 Min. :-2.369920 ## 1st Qu.:0.200 versicolor:50 1st Qu.:-0.544671 ## Median :0.800 virginica : 0 Median :-0.025141 ## Mean :0.786 Mean :-0.002907 ## 3rd Qu.:1.300 3rd Qu.: 0.550369 ## Max. :1.800 Max. : 2.357163 Here need more exercise for this chapter Exercise 3.22 3.3 For more in-depth exercises Go to: http://tryr.codeschool.com/ 1 This material is based on http://tryr.codeschool.com/ "]
]
